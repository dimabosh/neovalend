// SPDX-License-Identifier: MIT
pragma solidity ^0.8.10;

import '@openzeppelin/contracts/access/Ownable.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';

interface ISwapRouter {
    struct ExactInputSingleParams {
        address tokenIn;
        address tokenOut;
        uint24 fee;
        address recipient;
        uint256 deadline;
        uint256 amountIn;
        uint256 amountOutMinimum;
        uint160 sqrtPriceLimitX96;
    }

    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);

    struct ExactOutputSingleParams {
        address tokenIn;
        address tokenOut;
        uint24 fee;
        address recipient;
        uint256 deadline;
        uint256 amountOut;
        uint256 amountInMaximum;
        uint160 sqrtPriceLimitX96;
    }

    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);
}

interface IQuoter {
    function quoteExactInputSingle(
        address tokenIn,
        address tokenOut,
        uint24 fee,
        uint256 amountIn,
        uint160 sqrtPriceLimitX96
    ) external returns (uint256 amountOut);

    function quoteExactOutputSingle(
        address tokenIn,
        address tokenOut,
        uint24 fee,
        uint256 amountOut,
        uint160 sqrtPriceLimitX96
    ) external returns (uint256 amountIn);
}

/**
 * @title SwapIntegration
 * @author RubleN Team
 * @notice Integrates USDT ↔ A7A5 swaps through Uniswap V3 with fees and slippage protection
 * @dev Handles token swaps with 0.1% protocol fee and points distribution
 */
contract SwapIntegration is Ownable, ReentrancyGuard {
    using SafeERC20 for IERC20;

    // ============ State Variables ============

    /// @notice Uniswap V3 Router
    ISwapRouter public immutable swapRouter;
    
    /// @notice Uniswap V3 Quoter
    IQuoter public immutable quoter;
    
    /// @notice USDT token
    IERC20 public immutable USDT;
    
    /// @notice A7A5 token
    IERC20 public immutable A7A5;
    
    /// @notice Pool fee (0.3% = 3000)
    uint24 public constant POOL_FEE = 3000;
    
    /// @notice Protocol fee (0.1% = 100 basis points)
    uint256 public constant PROTOCOL_FEE = 100;
    
    /// @notice Basis points denominator
    uint256 public constant BASIS_POINTS = 10000;
    
    /// @notice Maximum slippage (5% = 500 basis points)
    uint256 public constant MAX_SLIPPAGE = 500;
    
    /// @notice Fee recipient
    address public feeRecipient;
    
    /// @notice Points system contract
    address public pointsSystem;

    // ============ Events ============

    event SwapExecuted(
        address indexed user,
        address tokenIn,
        address tokenOut,
        uint256 amountIn,
        uint256 amountOut,
        uint256 fee
    );
    
    event FeeRecipientUpdated(address indexed oldRecipient, address indexed newRecipient);
    event PointsSystemUpdated(address indexed oldPoints, address indexed newPoints);
    event SwapPointsAwarded(address indexed user, uint256 swapAmount, uint256 points);

    // ============ Constructor ============

    constructor(
        address _swapRouter,
        address _quoter,
        address _usdt,
        address _a7a5,
        address _feeRecipient
    ) {
        swapRouter = ISwapRouter(_swapRouter);
        quoter = IQuoter(_quoter);
        USDT = IERC20(_usdt);
        A7A5 = IERC20(_a7a5);
        feeRecipient = _feeRecipient;
    }

    // ============ External Functions ============

    /**
     * @notice Swap exact USDT for A7A5
     * @param amountIn Amount of USDT to swap
     * @param amountOutMinimum Minimum amount of A7A5 to receive
     * @param deadline Transaction deadline
     * @return amountOut Amount of A7A5 received
     */
    function swapUSDTForA7A5(
        uint256 amountIn,
        uint256 amountOutMinimum,
        uint256 deadline
    ) external nonReentrant returns (uint256 amountOut) {
        require(amountIn > 0, "SwapIntegration: Invalid amount");
        require(deadline >= block.timestamp, "SwapIntegration: Expired deadline");

        // Calculate protocol fee
        uint256 protocolFee = (amountIn * PROTOCOL_FEE) / BASIS_POINTS;
        uint256 swapAmount = amountIn - protocolFee;

        // Transfer tokens from user
        USDT.safeTransferFrom(msg.sender, address(this), amountIn);
        
        // Send protocol fee to fee recipient
        if (protocolFee > 0) {
            USDT.safeTransfer(feeRecipient, protocolFee);
        }

        // Approve router to spend USDT
        USDT.safeApprove(address(swapRouter), swapAmount);

        // Execute swap
        ISwapRouter.ExactInputSingleParams memory params = ISwapRouter.ExactInputSingleParams({
            tokenIn: address(USDT),
            tokenOut: address(A7A5),
            fee: POOL_FEE,
            recipient: msg.sender,
            deadline: deadline,
            amountIn: swapAmount,
            amountOutMinimum: amountOutMinimum,
            sqrtPriceLimitX96: 0
        });

        amountOut = swapRouter.exactInputSingle(params);

        // Award points
        _awardPoints(msg.sender, amountIn);

        emit SwapExecuted(msg.sender, address(USDT), address(A7A5), amountIn, amountOut, protocolFee);
    }

    /**
     * @notice Swap exact A7A5 for USDT
     * @param amountIn Amount of A7A5 to swap
     * @param amountOutMinimum Minimum amount of USDT to receive
     * @param deadline Transaction deadline
     * @return amountOut Amount of USDT received
     */
    function swapA7A5ForUSDT(
        uint256 amountIn,
        uint256 amountOutMinimum,
        uint256 deadline
    ) external nonReentrant returns (uint256 amountOut) {
        require(amountIn > 0, "SwapIntegration: Invalid amount");
        require(deadline >= block.timestamp, "SwapIntegration: Expired deadline");

        // Transfer A7A5 from user
        A7A5.safeTransferFrom(msg.sender, address(this), amountIn);

        // Approve router to spend A7A5
        A7A5.safeApprove(address(swapRouter), amountIn);

        // Execute swap
        ISwapRouter.ExactInputSingleParams memory params = ISwapRouter.ExactInputSingleParams({
            tokenIn: address(A7A5),
            tokenOut: address(USDT),
            fee: POOL_FEE,
            recipient: address(this),
            deadline: deadline,
            amountIn: amountIn,
            amountOutMinimum: amountOutMinimum,
            sqrtPriceLimitX96: 0
        });

        uint256 usdtReceived = swapRouter.exactInputSingle(params);

        // Calculate protocol fee
        uint256 protocolFee = (usdtReceived * PROTOCOL_FEE) / BASIS_POINTS;
        amountOut = usdtReceived - protocolFee;

        // Send USDT to user (minus fee)
        USDT.safeTransfer(msg.sender, amountOut);

        // Send protocol fee to fee recipient
        if (protocolFee > 0) {
            USDT.safeTransfer(feeRecipient, protocolFee);
        }

        // Award points (use original USDT value for points calculation)
        _awardPoints(msg.sender, usdtReceived);

        emit SwapExecuted(msg.sender, address(A7A5), address(USDT), amountIn, amountOut, protocolFee);
    }

    /**
     * @notice Get quote for USDT → A7A5 swap
     * @param amountIn Amount of USDT to swap
     * @return amountOut Expected amount of A7A5 to receive
     * @return protocolFee Protocol fee in USDT
     */
    function quoteUSDTForA7A5(uint256 amountIn) external returns (uint256 amountOut, uint256 protocolFee) {
        require(amountIn > 0, "SwapIntegration: Invalid amount");

        protocolFee = (amountIn * PROTOCOL_FEE) / BASIS_POINTS;
        uint256 swapAmount = amountIn - protocolFee;

        amountOut = quoter.quoteExactInputSingle(
            address(USDT),
            address(A7A5),
            POOL_FEE,
            swapAmount,
            0
        );
    }

    /**
     * @notice Get quote for A7A5 → USDT swap
     * @param amountIn Amount of A7A5 to swap
     * @return amountOut Expected amount of USDT to receive (after protocol fee)
     * @return protocolFee Protocol fee in USDT
     */
    function quoteA7A5ForUSDT(uint256 amountIn) external returns (uint256 amountOut, uint256 protocolFee) {
        require(amountIn > 0, "SwapIntegration: Invalid amount");

        uint256 usdtReceived = quoter.quoteExactInputSingle(
            address(A7A5),
            address(USDT),
            POOL_FEE,
            amountIn,
            0
        );

        protocolFee = (usdtReceived * PROTOCOL_FEE) / BASIS_POINTS;
        amountOut = usdtReceived - protocolFee;
    }

    /**
     * @notice Calculate minimum amount out with slippage protection
     * @param amountOut Expected amount out
     * @param slippageBasisPoints Slippage in basis points (max 500 = 5%)
     * @return minAmountOut Minimum amount out
     */
    function calculateMinAmountOut(uint256 amountOut, uint256 slippageBasisPoints) 
        external 
        pure 
        returns (uint256 minAmountOut) 
    {
        require(slippageBasisPoints <= MAX_SLIPPAGE, "SwapIntegration: Slippage too high");
        
        minAmountOut = amountOut - (amountOut * slippageBasisPoints / BASIS_POINTS);
    }

    // ============ Admin Functions ============

    /**
     * @notice Update fee recipient
     * @param newRecipient New fee recipient address
     */
    function updateFeeRecipient(address newRecipient) external onlyOwner {
        require(newRecipient != address(0), "SwapIntegration: Invalid address");
        
        address oldRecipient = feeRecipient;
        feeRecipient = newRecipient;
        
        emit FeeRecipientUpdated(oldRecipient, newRecipient);
    }

    /**
     * @notice Update points system contract
     * @param newPointsSystem New points system address
     */
    function updatePointsSystem(address newPointsSystem) external onlyOwner {
        address oldPoints = pointsSystem;
        pointsSystem = newPointsSystem;
        
        emit PointsSystemUpdated(oldPoints, newPointsSystem);
    }

    /**
     * @notice Emergency token withdrawal
     * @param token Token to withdraw
     * @param amount Amount to withdraw
     */
    function emergencyWithdraw(address token, uint256 amount) external onlyOwner {
        IERC20(token).safeTransfer(owner(), amount);
    }

    // ============ Internal Functions ============

    /**
     * @notice Award points for swap
     * @param user User address
     * @param swapAmount Swap amount in USD terms
     */
    function _awardPoints(address user, uint256 swapAmount) internal {
        if (pointsSystem != address(0)) {
            // Award 0.1 point per $100 swapped
            uint256 points = swapAmount / 100e6; // USDT has 6 decimals
            
            if (points > 0) {
                try IPointsSystem(pointsSystem).awardSwapPoints(user, points) {
                    emit SwapPointsAwarded(user, swapAmount, points);
                } catch {
                    // Points system failed, continue without reverting
                }
            }
        }
    }

    // ============ View Functions ============

    /**
     * @notice Get swap statistics
     * @return usdtBalance Contract USDT balance
     * @return a7a5Balance Contract A7A5 balance
     * @return feeRecipientAddress Current fee recipient
     */
    function getSwapInfo() external view returns (
        uint256 usdtBalance,
        uint256 a7a5Balance,
        address feeRecipientAddress
    ) {
        usdtBalance = USDT.balanceOf(address(this));
        a7a5Balance = A7A5.balanceOf(address(this));
        feeRecipientAddress = feeRecipient;
    }
}

interface IPointsSystem {
    function awardSwapPoints(address user, uint256 points) external;
}